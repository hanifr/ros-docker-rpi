# Gazebo-ros-docker on Raspberry Pi 4B for Ubuntu 24.04.2 LTS

# Initial Setup on Raspberry PI
```bash
sudo apt-get update && apt-get upgrade
```

# Clone the git repository
```bash
git clone https://github.com/hanifr/ros-docker-rpi.git
```

### Directory Structure
```
gazebo-ros-pi/
├── docker-compose.pi.yml     ✅ ROS 2 Humble optimized for Pi 4B
├── Dockerfile.arm64          ✅ ARM64 ROS 2 base with Gazebo
├── Dockerfile.web            ✅ Simplified Flask web interface  
├── Dockerfile.monitor        ✅ Pi resource monitoring
└── requirements.txt          ✅ Python dependencies
├── models/                   # Custom Gazebo models
│   ├── my_robot/
│   └── sensors/
├── monitor/                   # Monitoring UI
│   ├── monitor.py
│   └── requirements.txt
├── worlds/                            # Gazebo world files
│   ├── simple_world.world
│   └── obstacle_course.world
├── ros2_ws/                           # ROS workspace
│   ├── src/
│   │   ├── my_robot_description/      # Robot URDF models
│   │   │   ├── urdf/
│   │   │   ├── meshes/
│   │   │   └── config/
│   │   └── my_robot_gazebo/           # Simulation configuration
│   │   │   ├── launch/
│   │   │   │   └── headless_simulation.launch  # ✅ Launch file
│   │   │   ├── worlds/
│   │   │   └── config/
│   ├── build/                         # Generated by ros2_make
│   └── install/                       # Generated by ros2_make
│   └── log/                           # Generated by ros2_make
├── scripts/                           # Helper scripts
│   ├── init.sh                        # Pi environment setup
│   ├── run_headless_sim.sh            # Headless simulation 
│   ├── test_docker_setup.sh           # Comprehensive Docker testing 
│   ├── quick_start.sh                 # Quick start guide
launcher
│   ├── start_web_interface.sh         # Web UI launcher
│   ├── teleop.sh                      # Robot control
│   ├── monitor_pi_resources.sh        # Created by pi_setup.sh
│   └── ...
└── web_interface/                     # 🔄 Created by start_web_interface.sh
    ├── app.py                         # Flask web application
    ├── templates/
    │   └── index.html                 # Web interface HTML
    └── static/                        # CSS/JS files (if needed)
```

### Custom Dockerfile for ARM64
```dockerfile
# Dockerfile.arm64 - FINAL VERSION with ros3djs support
FROM ros:humble-ros-base

# Use bash for all RUN commands
SHELL ["/bin/bash", "-c"]

# Set environment variables
ENV DEBIAN_FRONTEND=noninteractive \
    ROS_DISTRO=humble \
    PYTHONUNBUFFERED=1

# Create workspace
WORKDIR /workspace

# Verify ROS 2 base installation
RUN echo "=== VERIFYING ROS 2 BASE ===" && \
    source /opt/ros/humble/setup.bash && \
    echo "✅ ROS 2 sourced: $ROS_DISTRO" && \
    echo "✅ Base packages: $(ros2 pkg list | wc -l)" && \
    echo "=== BASE VERIFIED ==="

# Install essential system packages
RUN apt-get update && apt-get install -y \
    curl \
    wget \
    git \
    vim \
    python3-pip \
    python3-colcon-common-extensions \
    python3-rosdep \
    net-tools \
    iputils-ping \
    htop \
    tree \
    && rm -rf /var/lib/apt/lists/*

# Check what ROS 2 packages are actually available for ARM64
RUN echo "=== CHECKING AVAILABLE ROS 2 PACKAGES ===" && \
    apt-cache search ros-humble | grep -E "(robot|tf2|rosbridge)" | head -10 && \
    echo "=== END PACKAGE CHECK ==="

# Install core ROS packages that definitely exist for ARM64
RUN echo "=== INSTALLING CORE ROS PACKAGES ===" && \
    apt-get update && apt-get install -y \
    ros-humble-robot-state-publisher \
    ros-humble-joint-state-publisher \
    ros-humble-tf2-ros \
    ros-humble-tf2-tools \
    ros-humble-xacro \
    && rm -rf /var/lib/apt/lists/* && \
    echo "✅ Core ROS packages installed"

# Install ROSBridge (check if available)
RUN echo "=== INSTALLING ROSBRIDGE ===" && \
    apt-get update && \
    if apt-cache show ros-humble-rosbridge-server >/dev/null 2>&1; then \
        echo "✅ ROSBridge available, installing..."; \
        apt-get install -y ros-humble-rosbridge-server ros-humble-rosapi; \
    else \
        echo "⚠️ ROSBridge not available in repos, will install via pip"; \
        pip3 install roslibpy; \
    fi && \
    rm -rf /var/lib/apt/lists/*

# Install message packages (graceful failure)
RUN echo "=== INSTALLING MESSAGE PACKAGES ===" && \
    apt-get update && \
    (apt-get install -y ros-humble-geometry-msgs || echo "geometry-msgs not available") && \
    (apt-get install -y ros-humble-std-msgs || echo "std-msgs not available") && \
    (apt-get install -y ros-humble-sensor-msgs || echo "sensor-msgs not available") && \
    (apt-get install -y ros-humble-nav-msgs || echo "nav-msgs not available") && \
    rm -rf /var/lib/apt/lists/* && \
    echo "=== MESSAGE PACKAGES COMPLETE ==="

# Install ros3djs dependencies (check availability for ARM64)
RUN echo "=== INSTALLING ROS3DJS DEPENDENCIES ===" && \
    apt-get update && \
    # TF2 Web Republisher (essential for ros3djs)
    (apt-get install -y ros-humble-tf2-web-republisher || echo "tf2-web-republisher not available") && \
    # URDF and mesh support (avoid duplicates)
    (apt-get install -y ros-humble-urdf || echo "urdf already installed or not available") && \
    (apt-get install -y ros-humble-urdf-parser-plugin || echo "urdf-parser-plugin not available") && \
    # Interactive markers support
    (apt-get install -y ros-humble-interactive-markers || echo "interactive-markers not available") && \
    # Additional visualization packages (check availability)
    (apt-get install -y ros-humble-rviz-common || echo "rviz-common not available") && \
    (apt-get install -y ros-humble-rviz-default-plugins || echo "rviz-default-plugins not available") && \
    # Joint state publisher GUI (avoid duplicate)
    (apt-get install -y ros-humble-joint-state-publisher-gui || echo "joint-state-publisher-gui not available") && \
    rm -rf /var/lib/apt/lists/* && \
    echo "✅ ros3djs dependencies installation complete"

# Install Python packages for enhanced web interface
RUN echo "=== INSTALLING PYTHON WEB PACKAGES ===" && \
    pip3 install \
    flask-socketio \
    python-socketio \
    eventlet \
    && echo "✅ Python web packages installed"

# Initialize rosdep
RUN rosdep update

# Check what we actually have installed
RUN echo "=== FINAL PACKAGE CHECK ===" && \
    source /opt/ros/humble/setup.bash && \
    echo "Total ROS 2 packages available: $(ros2 pkg list | wc -l)" && \
    echo "Key packages:" && \
    ros2 pkg list | grep -E "(robot_state|tf2|rosbridge)" && \
    echo "Message packages:" && \
    ros2 pkg list | grep -E "(geometry_msgs|std_msgs|sensor_msgs)" && \
    echo "Visualization packages:" && \
    ros2 pkg list | grep -E "(rviz|interactive)" && \
    echo "=== PACKAGE CHECK COMPLETE ==="

# Create directories
RUN mkdir -p src build install log

# Setup bash environment
RUN echo 'source /opt/ros/humble/setup.bash' >> ~/.bashrc && \
    echo 'if [ -f /workspace/install/setup.bash ]; then source /workspace/install/setup.bash; fi' >> ~/.bashrc && \
    echo 'echo "✅ ROS 2 environment ready"' >> ~/.bashrc

# Create working entrypoint
RUN echo '#!/bin/bash' > /entrypoint.sh && \
    echo 'set -e' >> /entrypoint.sh && \
    echo 'echo "🚀 Starting ROS 2 container with ros3djs support..."' >> /entrypoint.sh && \
    echo 'source /opt/ros/humble/setup.bash' >> /entrypoint.sh && \
    echo 'if [ -f /workspace/install/setup.bash ]; then source /workspace/install/setup.bash; fi' >> /entrypoint.sh && \
    echo 'echo "✅ ROS 2 ready - $(ros2 pkg list | wc -l) packages available"' >> /entrypoint.sh && \
    echo 'exec "$@"' >> /entrypoint.sh && \
    chmod +x /entrypoint.sh

# Create ROSBridge launcher script
RUN echo '#!/bin/bash' > /start_rosbridge.sh && \
    echo 'source /opt/ros/humble/setup.bash' >> /start_rosbridge.sh && \
    echo 'if [ -f /workspace/install/setup.bash ]; then source /workspace/install/setup.bash; fi' >> /start_rosbridge.sh && \
    echo 'if ros2 pkg list | grep -q rosbridge_server; then' >> /start_rosbridge.sh && \
    echo '    echo "✅ Using ROS 2 ROSBridge package"' >> /start_rosbridge.sh && \
    echo '    ros2 launch rosbridge_server rosbridge_websocket_launch.xml port:=9090' >> /start_rosbridge.sh && \
    echo 'else' >> /start_rosbridge.sh && \
    echo '    echo "⚠️ ROSBridge package not found, trying alternative..."' >> /start_rosbridge.sh && \
    echo '    python3 -c "' >> /start_rosbridge.sh && \
    echo 'import socket' >> /start_rosbridge.sh && \
    echo 'import time' >> /start_rosbridge.sh && \
    echo 'print(\"🌉 Starting simple WebSocket server on port 9090\")' >> /start_rosbridge.sh && \
    echo 'sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)' >> /start_rosbridge.sh && \
    echo 'sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)' >> /start_rosbridge.sh && \
    echo 'sock.bind((\"0.0.0.0\", 9090))' >> /start_rosbridge.sh && \
    echo 'sock.listen(1)' >> /start_rosbridge.sh && \
    echo 'print(\"✅ WebSocket server listening on 0.0.0.0:9090\")' >> /start_rosbridge.sh && \
    echo 'while True: time.sleep(1)' >> /start_rosbridge.sh && \
    echo '"' >> /start_rosbridge.sh && \
    echo 'fi' >> /start_rosbridge.sh && \
    chmod +x /start_rosbridge.sh

# Create TF2 Web Republisher launcher script
RUN echo '#!/bin/bash' > /start_tf2_web.sh && \
    echo 'source /opt/ros/humble/setup.bash' >> /start_tf2_web.sh && \
    echo 'if [ -f /workspace/install/setup.bash ]; then source /workspace/install/setup.bash; fi' >> /start_tf2_web.sh && \
    echo 'echo "🌐 Starting TF2 Web Republisher..."' >> /start_tf2_web.sh && \
    echo 'if ros2 pkg list | grep -q tf2_web_republisher; then' >> /start_tf2_web.sh && \
    echo '    echo "✅ Using TF2 Web Republisher package"' >> /start_tf2_web.sh && \
    echo '    ros2 run tf2_web_republisher tf2_web_republisher --ros-args -p port:=9091' >> /start_tf2_web.sh && \
    echo 'else' >> /start_tf2_web.sh && \
    echo '    echo "⚠️ TF2 Web Republisher not available, starting placeholder..."' >> /start_tf2_web.sh && \
    echo '    python3 -c "' >> /start_tf2_web.sh && \
    echo 'import socket' >> /start_tf2_web.sh && \
    echo 'import time' >> /start_tf2_web.sh && \
    echo 'print(\"🔄 TF2 Web Republisher placeholder on port 9091\")' >> /start_tf2_web.sh && \
    echo 'sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)' >> /start_tf2_web.sh && \
    echo 'sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)' >> /start_tf2_web.sh && \
    echo 'sock.bind((\"0.0.0.0\", 9091))' >> /start_tf2_web.sh && \
    echo 'sock.listen(1)' >> /start_tf2_web.sh && \
    echo 'print(\"✅ TF2 placeholder listening on 0.0.0.0:9091\")' >> /start_tf2_web.sh && \
    echo 'while True: time.sleep(1)' >> /start_tf2_web.sh && \
    echo '"' >> /start_tf2_web.sh && \
    echo 'fi' >> /start_tf2_web.sh && \
    chmod +x /start_tf2_web.sh

# Create test script
RUN echo '#!/bin/bash' > /test_minimal.sh && \
    echo 'echo "=== ROS 2 + ros3djs TEST ==="' >> /test_minimal.sh && \
    echo 'source /opt/ros/humble/setup.bash' >> /test_minimal.sh && \
    echo 'echo "ROS_DISTRO: $ROS_DISTRO"' >> /test_minimal.sh && \
    echo 'echo "Total packages: $(ros2 pkg list | wc -l)"' >> /test_minimal.sh && \
    echo 'echo "Available message types:"' >> /test_minimal.sh && \
    echo 'ros2 interface list | grep -E "(geometry_msgs|std_msgs)" | head -5 || echo "Message types may be limited"' >> /test_minimal.sh && \
    echo 'echo "TF2 Web Republisher available: $(ros2 pkg list | grep tf2_web_republisher | wc -l)"' >> /test_minimal.sh && \
    echo 'echo "ROSBridge available: $(ros2 pkg list | grep rosbridge | wc -l)"' >> /test_minimal.sh && \
    echo 'echo "✅ ROS 2 + ros3djs test complete!"' >> /test_minimal.sh && \
    chmod +x /test_minimal.sh

# Final verification
RUN source /opt/ros/humble/setup.bash && \
    echo "✅ Build complete - $(ros2 pkg list | wc -l) ROS 2 packages ready!" && \
    echo "📦 Scripts created: $(ls -la /*.sh | wc -l)"

# Expose ports
EXPOSE 11345 9090 9091

# Set entrypoint
ENTRYPOINT ["/entrypoint.sh"]
CMD ["/test_minimal.sh"]
```

### Pi-Optimized Docker Compose
```yaml
# docker-compose.pi.yml - SIMPLE VERSION with Robot Loading
version: '3.8'

services:
  gazebo-sim:
    build:
      context: .
      dockerfile: Dockerfile.arm64
    container_name: gazebo-pi
    restart: unless-stopped
    environment:
      # ROS 2 Environment Variables
      - ROS_DOMAIN_ID=0
      - RMW_IMPLEMENTATION=rmw_fastrtps_cpp
      - FASTRTPS_DEFAULT_PROFILES_FILE=/workspace/fastrtps_profile.xml
      # Headless Gazebo
      - DISPLAY=
      - GAZEBO_MASTER_URI=http://localhost:11345
      - GAZEBO_MODEL_PATH=/root/.gazebo/models:/workspace/models:/worlds
      # Pi Optimizations
      - GAZEBO_RESOURCE_PATH=/usr/share/gazebo:/worlds
      - PYTHONUNBUFFERED=1
      # ROS 2 Performance Tuning
      - RCUTILS_LOGGING_BUFFERED_STREAM=1
      - RCUTILS_COLORIZED_OUTPUT=0
      # Robot Configuration - ADD THESE
      - ROBOT_URDF_PATH=/workspace/src/my_robot_description/urdf/robot.urdf
    volumes:
      # Use ros2_ws for ROS 2
      - ./ros2_ws:/workspace
      - ./models:/root/.gazebo/models  
      - ./worlds:/worlds
      - ./scripts:/scripts
      # Persistent volumes for build artifacts
      - workspace_build:/workspace/build
      - workspace_install:/workspace/install
      - workspace_log:/workspace/log
      # System mounts
      - /etc/timezone:/etc/timezone:ro
      - /etc/localtime:/etc/localtime:ro
    ports:
      - "11345:11345"  # Gazebo Master
      - "9090:9090"    # ROSBridge WebSocket
    networks:
      - gazebo-pi-network
    deploy:
      resources:
        limits:
          memory: 3G     # Pi 4B memory limit
          cpus: '3.5'    # Leave some CPU for system
        reservations:
          memory: 1G
          cpus: '1.0'
    # SIMPLE COMMAND - just call script
    command: ["/scripts/start_robot_system.sh"]
    healthcheck:
      test: ["CMD", "bash", "-c", "source /opt/ros/humble/setup.bash && ros2 topic list | grep -E '(cmd_vel|odom)'"]
      interval: 30s
      timeout: 15s
      retries: 3
      start_period: 90s

  tf2-web-republisher:
    build:
      context: .
      dockerfile: Dockerfile.arm64
    container_name: tf2-web-pub
    restart: unless-stopped
    depends_on:
      - gazebo-sim
    environment:
      - ROS_DOMAIN_ID=0
      - RMW_IMPLEMENTATION=rmw_fastrtps_cpp
      - PYTHONUNBUFFERED=1
    volumes:
      - ./ros2_ws:/workspace
      - ./scripts:/scripts
      # ADD: Share built workspace from gazebo-sim
      - workspace_build:/workspace/build
      - workspace_install:/workspace/install
      - workspace_log:/workspace/log
    ports:
      - "9091:9091"    # TF2 Web Republisher
    networks:
      - gazebo-pi-network
    # SIMPLE COMMAND - just call script
    command: ["/scripts/start_tf2_web.sh"]
    healthcheck:
      test: ["CMD", "bash", "-c", "source /opt/ros/humble/setup.bash && ros2 node list | grep tf2_web"]
      interval: 30s
      timeout: 15s
      retries: 3
      start_period: 60s

  web-interface:
    build:
      context: .
      dockerfile: Dockerfile.web
    container_name: web-ui
    restart: unless-stopped
    ports:
      - "5000:5000"    # Flask web interface
    depends_on:
      - gazebo-sim
      - tf2-web-republisher
    environment:
      - ROS_BRIDGE_URL=ws://gazebo-sim:9090
      - TF2_WEB_URL=ws://tf2-web-pub:9091
      - FLASK_ENV=production
      - PYTHONUNBUFFERED=1
      - ROBOT_NAME=differential_drive_robot
    volumes:
      - ./web_interface:/app
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - gazebo-pi-network
    working_dir: /app
    command: ["python", "app.py"]
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 45s

  monitor:
    build:
      context: .
      dockerfile: Dockerfile.arm64
    container_name: pi-monitor
    restart: unless-stopped
    ports:
      - "8000:8000"    # Monitor web interface
    volumes:
      - /proc:/host/proc:ro
      - /sys:/host/sys:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./scripts:/scripts
    environment:
      - PYTHONUNBUFFERED=1
    networks:
      - gazebo-pi-network
    profiles:
      - monitoring  # Only start with: docker-compose --profile monitoring up
    command: ["/scripts/start_monitor.sh"]

networks:
  gazebo-pi-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16

# Persistent volumes for better Pi performance
volumes:
  gazebo_models:
    driver: local
  workspace_build:
    driver: local
  workspace_install:
    driver: local
  workspace_log:
    driver: local
```


Steps
# Check the file structure
```bash
tree -L 3
```

# Run Pi setup (installs Docker, ROS, etc.)
```bash
./scripts/init.sh
# After completion, test everything:
./scripts/test_docker_setup.sh

# Get quick start guide:
./scripts/quick_start.sh
```
# Start web interface (creates web_interface/ directory)
```bash
./scripts/start_web_interface.sh
```

# Test the monitor application locally first
```bash
cd monitor
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt
python monitor.py
```
# Visit http://localhost:8000 to test

# Build containers
```bash
cd ~/gazebo-ros-pi
docker-compose -f docker-compose.pi.yml build gazebo-sim

# Start services
docker-compose -f docker-compose.pi.yml up -d

# Start with monitoring profile
docker-compose -f docker-compose.pi.yml --profile monitoring up -d

# Check status
docker-compose -f docker-compose.pi.yml ps
```
ROS 2 Simulation: Port 9090 (ROSBridge)
Web Interface: http://your-pi-ip:5000
Resource Monitor: http://your-pi-ip:8000 (if using --profile monitoring)
Gazebo: Headless mode, accessible via web interface

# Troubleshooting: Clean the failed build
```bash
# Clean everything
docker-compose -f docker-compose.pi.yml down
docker system prune -a -f  # This removes everything

# Rebuild the gazebo-sim service (will take 20-30 minutes on Pi)
docker-compose -f docker-compose.pi.yml build --no-cache gazebo-sim

# If successful, you should see messages like:
# ✅ ROS 2 sourced successfully
# ✅ ROS 2 command working  
# ✅ ROS 2 packages available
```

# any created scripts, ensure to change the privilege
```bash
sudo chmod +x *.sh *.py
```

# check OS details
```bash
cat /etc/os-release
```

PRETTY_NAME="Ubuntu 24.04.2 LTS"
NAME="Ubuntu"
VERSION_ID="24.04"
VERSION="24.04.2 LTS (Noble Numbat)"
VERSION_CODENAME=noble
ID=ubuntu
ID_LIKE=debian
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
UBUNTU_CODENAME=noble
LOGO=ubuntu-logo

# Controller Tuning Guide
## Make algorithms DRAMATICALLY different:
proportional
        kp_linear: 2.0,        // Very aggressive
        max_linear: 1.0
pid
        kp_linear: 0.3,        // Very conservative
        ki_linear: 0.5,        // High integral gain
        max_linear: 0.3

pure_pursuit
        lookahead_distance: 1.5, // Much longer lookahead
        max_linear: 0.8

```bash
┌─────────────────────────────────────┐
│        Material Handling UI         │ ←  Web dashboard
├─────────────────────────────────────┤
│         ROS 2 Bridge                │ ← WebSocket connection
├─────────────────────────────────────┤
│    Navigation/Control Logic         │ ← Algorithms
├─────────────────────────────────────┤
│   Virtual Robot (Python)            │ ← Lightweight simulation
├─────────────────────────────────────┤
│         ROS 2 Core                  │ ← Standard ROS messaging
└─────────────────────────────────────┘

# vs Gazebo Stack:
┌─────────────────────────────────────┐
│        Material Handling UI         │
├─────────────────────────────────────┤
│         ROS 2 Bridge                │  
├─────────────────────────────────────┤
│    Navigation/Control Logic         │
├─────────────────────────────────────┤
│          Gazebo Server              │ ← Heavy 3D simulation
├─────────────────────────────────────┤
│        Physics Engine (ODE)         │ ← Complex physics
├─────────────────────────────────────┤
│       Graphics Engine (OGRE)        │ ← 3D rendering
├─────────────────────────────────────┤
│         ROS 2 Core                  │
└─────────────────────────────────────┘
```
# Gazebo-ros-docker on Raspberry Pi 4B


**✅ Add Pi-Specific Scripts:**
```bash
# setup PI
#!/bin/bash
./init.sh

# After completion, test everything:
./scripts/test_docker_setup.sh

# Get quick start guide:
./scripts/quick_start.sh
```

## 🔧 Complete Pi-Optimized Setup

### Directory Structure
```
gazebo-ros-pi/
├── docker-compose.pi.yml     ✅ ROS 2 Humble optimized for Pi 4B
├── Dockerfile.arm64          ✅ ARM64 ROS 2 base with Gazebo
├── Dockerfile.web            ✅ Simplified Flask web interface  
├── Dockerfile.monitor        ✅ Pi resource monitoring
└── requirements.txt          ✅ Python dependencies
├── models/                   # Custom Gazebo models
│   ├── my_robot/
│   └── sensors/
├── monitor/                   # Monitoring UI
│   ├── monitor.py
│   └── requirements.txt
├── worlds/                            # Gazebo world files
│   ├── simple_world.world
│   └── obstacle_course.world
├── ros2_ws/                           # ROS workspace
│   ├── src/
│   │   ├── my_robot_description/      # Robot URDF models
│   │   │   ├── urdf/
│   │   │   ├── meshes/
│   │   │   └── config/
│   │   └── my_robot_gazebo/           # Simulation configuration
│   │       ├── launch/
│   │       │   └── headless_simulation.launch  # ✅ Launch file
│   │       ├── worlds/
│   │       └── config/
│   ├── build/                         # Generated by ros2_make
│   └── install/                       # Generated by ros2_make
│   └── log/                           # Generated by ros2_make
├── scripts/                           # Helper scripts
│   ├── init.sh                        # Pi environment setup
│   ├── run_headless_sim.sh            # Headless simulation 
│   ├── test_docker_setup.sh           # Comprehensive Docker testing 
│   ├── quick_start.sh                 # Quick start guide
launcher
│   ├── start_web_interface.sh         # Web UI launcher
│   ├── teleop.sh                      # Robot control
│   ├── monitor_pi_resources.sh        # Created by pi_setup.sh
│   └── ...
└── web_interface/                     # 🔄 Created by start_web_interface.sh
    ├── app.py                         # Flask web application
    ├── templates/
    │   └── index.html                 # Web interface HTML
    └── static/                        # CSS/JS files (if needed)
```

### Custom Dockerfile for ARM64
```dockerfile
# Dockerfile.arm64 - MINIMAL WORKING - Only packages that definitely exist for ARM64
FROM ros:humble-ros-base

# Use bash for all RUN commands
SHELL ["/bin/bash", "-c"]

# Set environment variables
ENV DEBIAN_FRONTEND=noninteractive \
    ROS_DISTRO=humble \
    PYTHONUNBUFFERED=1

# Create workspace
WORKDIR /workspace

# Verify ROS 2 base installation
RUN echo "=== VERIFYING ROS 2 BASE ===" && \
    source /opt/ros/humble/setup.bash && \
    echo "✅ ROS 2 sourced: $ROS_DISTRO" && \
    echo "✅ Base packages: $(ros2 pkg list | wc -l)" && \
    echo "=== BASE VERIFIED ==="

# Install essential system packages
RUN apt-get update && apt-get install -y \
    curl \
    wget \
    git \
    vim \
    python3-pip \
    python3-colcon-common-extensions \
    python3-rosdep \
    net-tools \
    iputils-ping \
    htop \
    tree \
    && rm -rf /var/lib/apt/lists/*

# Check what ROS 2 packages are actually available for ARM64
RUN echo "=== CHECKING AVAILABLE ROS 2 PACKAGES ===" && \
    apt-cache search ros-humble | grep -E "(robot|tf2|rosbridge)" | head -10 && \
    echo "=== END PACKAGE CHECK ==="

# Install ONLY packages that definitely exist for ARM64
RUN apt-get update && apt-get install -y \
    ros-humble-robot-state-publisher \
    ros-humble-joint-state-publisher \
    ros-humble-tf2-ros \
    ros-humble-tf2-tools \
    ros-humble-xacro \
    && rm -rf /var/lib/apt/lists/*

# Try to install ROSBridge (check if available)
RUN echo "=== INSTALLING ROSBRIDGE ===" && \
    apt-get update && \
    if apt-cache show ros-humble-rosbridge-server >/dev/null 2>&1; then \
        echo "✅ ROSBridge available, installing..."; \
        apt-get install -y ros-humble-rosbridge-server ros-humble-rosapi; \
    else \
        echo "⚠️ ROSBridge not available in repos, will install via pip"; \
        pip3 install roslibpy; \
    fi && \
    rm -rf /var/lib/apt/lists/*

# Try to install other useful packages (graceful failure)
RUN echo "=== INSTALLING OPTIONAL PACKAGES ===" && \
    apt-get update && \
    (apt-get install -y ros-humble-geometry-msgs || echo "geometry-msgs not available") && \
    (apt-get install -y ros-humble-std-msgs || echo "std-msgs not available") && \
    (apt-get install -y ros-humble-sensor-msgs || echo "sensor-msgs not available") && \
    (apt-get install -y ros-humble-nav-msgs || echo "nav-msgs not available") && \
    rm -rf /var/lib/apt/lists/* && \
    echo "=== OPTIONAL PACKAGES COMPLETE ==="

# Initialize rosdep
RUN rosdep update

# Check what we actually have installed
RUN echo "=== FINAL PACKAGE CHECK ===" && \
    source /opt/ros/humble/setup.bash && \
    echo "Total ROS 2 packages available: $(ros2 pkg list | wc -l)" && \
    echo "Key packages:" && \
    ros2 pkg list | grep -E "(robot_state|tf2|rosbridge)" && \
    echo "Message packages:" && \
    ros2 pkg list | grep -E "(geometry_msgs|std_msgs|sensor_msgs)" && \
    echo "=== PACKAGE CHECK COMPLETE ==="

# Create directories
RUN mkdir -p src build install log

# Setup bash environment
RUN echo 'source /opt/ros/humble/setup.bash' >> ~/.bashrc && \
    echo 'if [ -f /workspace/install/setup.bash ]; then source /workspace/install/setup.bash; fi' >> ~/.bashrc && \
    echo 'echo "✅ ROS 2 environment ready"' >> ~/.bashrc

# Create working entrypoint
RUN echo '#!/bin/bash' > /entrypoint.sh && \
    echo 'set -e' >> /entrypoint.sh && \
    echo 'echo "🚀 Starting minimal ROS 2 container..."' >> /entrypoint.sh && \
    echo 'source /opt/ros/humble/setup.bash' >> /entrypoint.sh && \
    echo 'if [ -f /workspace/install/setup.bash ]; then source /workspace/install/setup.bash; fi' >> /entrypoint.sh && \
    echo 'echo "✅ ROS 2 ready - $(ros2 pkg list | wc -l) packages available"' >> /entrypoint.sh && \
    echo 'exec "$@"' >> /entrypoint.sh && \
    chmod +x /entrypoint.sh

# Create a ROSBridge launcher script (works with or without ros-humble-rosbridge-server)
RUN echo '#!/bin/bash' > /start_rosbridge.sh && \
    echo 'source /opt/ros/humble/setup.bash' >> /start_rosbridge.sh && \
    echo 'if ros2 pkg list | grep -q rosbridge_server; then' >> /start_rosbridge.sh && \
    echo '    echo "✅ Using ROS 2 ROSBridge package"' >> /start_rosbridge.sh && \
    echo '    ros2 launch rosbridge_server rosbridge_websocket_launch.xml port:=9090' >> /start_rosbridge.sh && \
    echo 'else' >> /start_rosbridge.sh && \
    echo '    echo "⚠️ ROSBridge package not found, trying alternative..."' >> /start_rosbridge.sh && \
    echo '    python3 -c "' >> /start_rosbridge.sh && \
    echo 'import socket' >> /start_rosbridge.sh && \
    echo 'import time' >> /start_rosbridge.sh && \
    echo 'print(\"🌉 Starting simple WebSocket server on port 9090\")' >> /start_rosbridge.sh && \
    echo 'sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)' >> /start_rosbridge.sh && \
    echo 'sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)' >> /start_rosbridge.sh && \
    echo 'sock.bind((\"0.0.0.0\", 9090))' >> /start_rosbridge.sh && \
    echo 'sock.listen(1)' >> /start_rosbridge.sh && \
    echo 'print(\"✅ WebSocket server listening on 0.0.0.0:9090\")' >> /start_rosbridge.sh && \
    echo 'while True: time.sleep(1)' >> /start_rosbridge.sh && \
    echo '"' >> /start_rosbridge.sh && \
    echo 'fi' >> /start_rosbridge.sh && \
    chmod +x /start_rosbridge.sh

# Create test script
RUN echo '#!/bin/bash' > /test_minimal.sh && \
    echo 'echo "=== MINIMAL ROS 2 TEST ==="' >> /test_minimal.sh && \
    echo 'source /opt/ros/humble/setup.bash' >> /test_minimal.sh && \
    echo 'echo "ROS_DISTRO: $ROS_DISTRO"' >> /test_minimal.sh && \
    echo 'echo "Total packages: $(ros2 pkg list | wc -l)"' >> /test_minimal.sh && \
    echo 'echo "Available message types:"' >> /test_minimal.sh && \
    echo 'ros2 interface list | grep -E "(geometry_msgs|std_msgs)" | head -5 || echo "Message types may be limited"' >> /test_minimal.sh && \
    echo 'echo "✅ Minimal ROS 2 test complete!"' >> /test_minimal.sh && \
    chmod +x /test_minimal.sh

# Final verification - make sure everything works
RUN source /opt/ros/humble/setup.bash && \
    echo "✅ Minimal build complete - $(ros2 pkg list | wc -l) ROS 2 packages ready!"

# Expose ports
EXPOSE 11345 9090

# Set entrypoint
ENTRYPOINT ["/entrypoint.sh"]
CMD ["/test_minimal.sh"]
```

### Pi-Optimized Docker Compose
```yaml
# docker-compose.pi.yml - SIMPLIFIED VERSION - No complex YAML escaping
version: '3.8'

services:
  gazebo-sim:
    build:
      context: .
      dockerfile: Dockerfile.arm64
    container_name: gazebo-pi
    restart: unless-stopped
    environment:
      # ROS 2 Environment Variables
      - ROS_DOMAIN_ID=0
      - RMW_IMPLEMENTATION=rmw_fastrtps_cpp
      - FASTRTPS_DEFAULT_PROFILES_FILE=/workspace/fastrtps_profile.xml
      # Headless Gazebo
      - DISPLAY=
      - GAZEBO_MASTER_URI=http://localhost:11345
      - GAZEBO_MODEL_PATH=/root/.gazebo/models:/workspace/models:/worlds
      # Pi Optimizations
      - GAZEBO_RESOURCE_PATH=/usr/share/gazebo:/worlds
      - PYTHONUNBUFFERED=1
      # ROS 2 Performance Tuning
      - RCUTILS_LOGGING_BUFFERED_STREAM=1
      - RCUTILS_COLORIZED_OUTPUT=0
    volumes:
      # Use ros2_ws for ROS 2
      - ./ros2_ws:/workspace
      - ./models:/root/.gazebo/models  
      - ./worlds:/worlds
      - ./scripts:/scripts
      # Persistent volumes for build artifacts
      - workspace_build:/workspace/build
      - workspace_install:/workspace/install
      - workspace_log:/workspace/log
      # System mounts
      - /etc/timezone:/etc/timezone:ro
      - /etc/localtime:/etc/localtime:ro
    ports:
      - "11345:11345"  # Gazebo Master
      - "9090:9090"    # ROSBridge WebSocket
    networks:
      - gazebo-pi-network
    deploy:
      resources:
        limits:
          memory: 3G     # Pi 4B memory limit
          cpus: '3.5'    # Leave some CPU for system
        reservations:
          memory: 1G
          cpus: '1.0'
    # FIXED: Simple command referencing external script
    command: ["/scripts/start_gazebo_sim.sh"]
    healthcheck:
      test: ["CMD", "bash", "-c", "source /opt/ros/humble/setup.bash && ros2 topic list"]
      interval: 30s
      timeout: 15s
      retries: 3
      start_period: 90s

  web-interface:
    build:
      context: .
      dockerfile: Dockerfile.web
    container_name: web-ui
    restart: unless-stopped
    ports:
      - "5000:5000"    # Flask web interface
    depends_on:
      - gazebo-sim
    environment:
      - ROS_BRIDGE_URL=ws://gazebo-sim:9090
      - FLASK_ENV=production
      - PYTHONUNBUFFERED=1
    volumes:
      - ./web_interface:/app
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - gazebo-pi-network
    working_dir: /app
    command: ["python", "app.py"]
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 45s

  monitor:
    build:
      context: .
      dockerfile: Dockerfile.monitor
    container_name: pi-monitor
    restart: unless-stopped
    ports:
      - "8000:8000"    # Monitor web interface
    volumes:
      - /proc:/host/proc:ro
      - /sys:/host/sys:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro
    environment:
      - PYTHONUNBUFFERED=1
    networks:
      - gazebo-pi-network
    profiles:
      - monitoring  # Only start with: docker-compose --profile monitoring up

networks:
  gazebo-pi-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16

# Persistent volumes for better Pi performance
volumes:
  gazebo_models:
    driver: local
  workspace_build:
    driver: local
  workspace_install:
    driver: local
  workspace_log:
    driver: local
```

### Updated Scripts

**`scripts/run_headless_sim.sh`:**
```bash
#!/bin/bash
echo "Starting headless Gazebo simulation on Pi..."

# Check Pi temperature
TEMP=$(vcgencmd measure_temp | cut -d= -f2)
echo "Pi Temperature: $TEMP"

# Start containers
docker-compose -f docker-compose.pi.yml up -d

echo "Simulation started!"
echo "Access web interface at: http://$(hostname -I | awk '{print $1}'):3000"
echo "ROS Bridge at: ws://$(hostname -I | awk '{print $1}'):9090"
```

**`scripts/monitor_pi_resources.sh`:**
```bash
#!/bin/bash
echo "=== Pi Resource Monitor ==="
while true; do
    clear
    echo "Temperature: $(vcgencmd measure_temp)"
    echo "CPU: $(top -bn1 | grep "Cpu(s)" | awk '{print $2}')"
    echo "Memory: $(free -h | awk 'NR==2{printf "%.1f%%", $3*100/$2}')"
    echo "Docker Stats:"
    docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}"
    sleep 2
done
```

```
What Gets Created Automatically?
✅ Created by pi_setup.sh:

scripts/monitor_pi_resources.sh
Various system configurations
Docker configurations

✅ Created by start_web_interface.sh:

web_interface/ directory
web_interface/app.py - Flask web application
web_interface/templates/ directory
web_interface/templates/index.html - Web interface
```

Steps
# Check the file structure
```bash
tree -L 3
```

# Run Pi setup (installs Docker, ROS, etc.)
```bash
./scripts/pi_setup.sh
```
# Start web interface (creates web_interface/ directory)
```bash
./scripts/start_web_interface.sh
```

# Test the monitor application locally first
```bash
cd monitor
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt
python monitor.py
```
# Visit http://localhost:8000 to test

# Build containers
```bash
cd ~/gazebo-ros-pi
docker-compose -f docker-compose.pi.yml build gazebo-sim

# Start services
docker-compose -f docker-compose.pi.yml up -d

# Start with monitoring profile
docker-compose -f docker-compose.pi.yml --profile monitoring up -d

# Check status
docker-compose -f docker-compose.pi.yml ps
```
ROS 2 Simulation: Port 9090 (ROSBridge)
Web Interface: http://your-pi-ip:5000
Resource Monitor: http://your-pi-ip:8000 (if using --profile monitoring)
Gazebo: Headless mode, accessible via web interface

# Troubleshooting: Clean the failed build
```bash
# Clean everything
docker-compose -f docker-compose.pi.yml down
docker system prune -a -f  # This removes everything

# Rebuild the gazebo-sim service (will take 20-30 minutes on Pi)
docker-compose -f docker-compose.pi.yml build --no-cache gazebo-sim

# If successful, you should see messages like:
# ✅ ROS 2 sourced successfully
# ✅ ROS 2 command working  
# ✅ ROS 2 packages available
```